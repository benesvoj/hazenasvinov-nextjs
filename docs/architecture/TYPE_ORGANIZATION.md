# Type Organization

## Overview

This codebase follows a strict type organization pattern that separates **database schemas** (auto-generated) from **application data types** (manually maintained). This separation ensures type safety while allowing flexibility for application-specific needs.

## Type Directory Structure

```
src/types/entities/{entity}/
├── schema/
│   └── {entity}Schema.ts        # Auto-generated from database
├── data/
│   └── {entity}.ts              # Application types with relations
└── index.ts                     # Exports
```

## Type Categories

### 1. Schema Types (Auto-Generated)

**Location**: `src/types/entities/{entity}/schema/`

**Purpose**: Direct representation of database tables

**Generation**: Auto-generated by `npm run generate:types`

**Example**:
```typescript
// src/types/entities/video/schema/videosSchema.ts
/**
 * Database schema for `videos` table
 *
 * ⚠️ AUTO-GENERATED - DO NOT EDIT MANUALLY
 * Generated by: scripts/split-db-types.js
 * Source: src/types/database/supabase.ts
 */

export interface VideoSchema {
  category_id: string;
  club_id: string | null;
  created_at: string | null;
  created_by: string | null;
  description: string | null;
  duration: string | null;
  id: string;
  is_active: boolean | null;
  recording_date: string | null;
  season_id: string | null;
  thumbnail_url: string | null;
  title: string;
  updated_at: string | null;
  updated_by: string | null;
  youtube_id: string;
  youtube_url: string;
}

export type VideoInsert = Omit<
  VideoSchema,
  'id' | 'created_at' | 'updated_at'
> & {
  id?: string; // Optional for inserts
};

export type VideoUpdate = {
  id: string;
} & Partial<Omit<VideoSchema, 'id' | 'created_at' | 'updated_at'>>;
```

**Characteristics**:
- ⚠️ **Never edit manually** - will be overwritten
- ✅ Exact match to database columns
- ✅ Includes all nullable fields
- ✅ Auto-generates Insert and Update types

### 2. Data Types (Manually Maintained)

**Location**: `src/types/entities/{entity}/data/`

**Purpose**: Application-specific types with relations and computed fields

**Example**:
```typescript
// src/types/entities/video/data/video.ts
import {VideoSchema} from '../schema/videosSchema';

/**
 * Video with joined relations
 * Used when fetching videos with category/club/season data
 */
export interface Video extends VideoSchema {
  category?: {
    id: string;
    name: string;
    code: string;
  };
  clubs?: {
    id: string;
    name: string;
    short_name: string;
  };
  seasons?: {
    id: string;
    name: string;
    start_date: string;
    end_date: string;
  };
  match_ids?: string[];
}

/**
 * Video with associated match information
 * Used in match preparation contexts
 */
export interface VideoWithMatch extends VideoSchema {
  match?: {
    id: string;
    date: string;
    status: 'upcoming' | 'completed';
    home_team: {
      id: string;
      name: string;
      short_name: string;
    };
    away_team: {
      id: string;
      name: string;
      short_name: string;
    };
    home_score?: number | null;
    away_score?: number | null;
    home_score_halftime?: number | null;
    away_score_halftime?: number | null;
  };
}

/**
 * Form data for creating/editing videos
 * Subset of VideoSchema with only user-editable fields
 */
export interface VideoFormData {
  title: string;
  description: string | null;
  youtube_url: string;
  category_id: string;
  club_id: string | null;
  recording_date: string | null;
  season_id: string | null;
  is_active: boolean;
}

/**
 * Filter criteria for videos
 */
export interface VideoFilters {
  category_id?: string;
  club_id?: string;
  season_id?: string;
  is_active?: boolean;
  search?: string;
}
```

**Characteristics**:
- ✅ Manually maintained
- ✅ Extends schema types
- ✅ Adds joined relations
- ✅ Context-specific types

## Type Usage Patterns

### Pattern 1: Base Schema Types

Use schema types when working directly with database:

```typescript
// ✅ Query layer - use schema types
export async function getAllVideos(
  ctx: QueryContext
): Promise<QueryResult<VideoSchema[]>> {
  const {data} = await ctx.supabase
    .from('videos')
    .select('*');

  return {data: data as VideoSchema[], error: null};
}

// ✅ CRUD operations
const insertData: VideoInsert = {
  title: 'New Video',
  youtube_url: 'https://...',
  // ... other required fields
};
```

### Pattern 2: Extended Types with Relations

Use extended types when fetching with joins:

```typescript
// ✅ Fetch with relations
export async function getVideosWithRelations(
  ctx: QueryContext
): Promise<QueryResult<Video[]>> {
  const {data} = await ctx.supabase
    .from('videos')
    .select(`
      *,
      category:categories(id, name, code),
      clubs(id, name, short_name),
      seasons(id, name, start_date, end_date)
    `);

  return {data: data as Video[], error: null};
}
```

### Pattern 3: Context-Specific Types

Create specific types for specific contexts:

```typescript
// ✅ Match preparation context
const processedVideos = useMemo<VideoWithMatch[]>(() => {
  return videos.map((video) => ({
    ...video,
    match: video.match_videos?.[0]?.match
      ? {
          id: video.match_videos[0].match.id,
          // ... match data
        }
      : undefined,
  }));
}, [videos]);

// Component expects videos with match
<CompactVideoList videos={processedVideos} />
```

### Pattern 4: Form Data Types

Use form data types for user input:

```typescript
// ✅ Form hook
export const useVideoForm = createFormHook<VideoSchema, VideoFormData>({
  initialFormData: {
    title: '',
    description: '',
    youtube_url: '',
    category_id: '',
    club_id: '',
    recording_date: '',
    season_id: '',
    is_active: true,
  },
  validationRules: [/* ... */],
});

// ✅ Transform form data to insert data
function transformToInsert(formData: VideoFormData): VideoInsert {
  return {
    ...formData,
    youtube_id: extractYoutubeId(formData.youtube_url),
    duration: null,
    thumbnail_url: null,
    created_by: null,
    updated_by: null,
  };
}
```

## Type Naming Conventions

### Schema Types
- `{Entity}Schema` - Base database schema
- `{Entity}Insert` - Type for INSERT operations (no id, timestamps)
- `{Entity}Update` - Type for UPDATE operations (all fields optional)

### Data Types
- `{Entity}` - Base entity with common relations
- `{Entity}With{Context}` - Entity with specific context (e.g., `VideoWithMatch`)
- `{Entity}FormData` - Form input data
- `{Entity}Filters` - Filter criteria

### Examples:
```typescript
// Schema types
VideoSchema
VideoInsert
VideoUpdate

// Data types
Video              // With standard relations
VideoWithMatch     // With match data
VideoWithMetadata  // With metadata
VideoFormData      // Form data
VideoFilters       // Filter criteria
```

## Type Extension Patterns

### Extending Schema Types

```typescript
// ✅ Extend with optional relations
export interface Video extends VideoSchema {
  category?: Category;
  clubs?: Club;
}

// ✅ Extend with computed fields
export interface VideoWithAnalytics extends VideoSchema {
  viewCount: number;
  engagementRate: number;
  lastViewedAt: string | null;
}
```

### Creating Context-Specific Types

```typescript
// ✅ For specific use cases
export interface VideoWithMatch extends VideoSchema {
  match?: MatchData;
}

export interface VideoForExport extends Pick<VideoSchema, 'title' | 'youtube_url' | 'recording_date'> {
  categoryName: string;
  clubName: string;
}
```

### Union Types for States

```typescript
// ✅ State-based types
export type VideoWithStatus =
  | (VideoSchema & { status: 'draft' })
  | (VideoSchema & { status: 'published'; published_at: string });
```

## Type Organization by Entity

### Example: Complete Video Types

```
src/types/entities/video/
├── schema/
│   └── videosSchema.ts
│       - VideoSchema (auto-generated)
│       - VideoInsert (auto-generated)
│       - VideoUpdate (auto-generated)
├── data/
│   └── video.ts
│       - Video (with standard relations)
│       - VideoWithMatch (with match data)
│       - VideoFormData (form input)
│       - VideoFilters (filter criteria)
└── index.ts
    - Re-exports all types
```

## Type Generation Workflow

### When Database Schema Changes:

1. **Update Database**: Run migrations
2. **Regenerate Types**: `npm run generate:types`
3. **Check Schema Files**: Review generated `{entity}Schema.ts` files
4. **Update Data Types**: Manually update data types if needed
5. **Fix Type Errors**: Run `npx tsc` and fix any errors

### Adding New Entity:

1. **Create Directory Structure**:
   ```bash
   mkdir -p src/types/entities/new-entity/schema
   mkdir -p src/types/entities/new-entity/data
   ```

2. **Generate Schema**: Run `npm run generate:types`

3. **Create Data Types**:
   ```typescript
   // src/types/entities/new-entity/data/newEntity.ts
   import {NewEntitySchema} from '../schema/newEntitySchema';

   export interface NewEntity extends NewEntitySchema {
     // Add relations and computed fields
   }

   export interface NewEntityFormData {
     // Add form fields
   }
   ```

4. **Export Types**:
   ```typescript
   // src/types/entities/new-entity/index.ts
   export * from './schema/newEntitySchema';
   export * from './data/newEntity';
   ```

5. **Add to Main Index**:
   ```typescript
   // src/types/index.ts
   export * from './entities/new-entity';
   ```

## Common Type Patterns

### Pattern: Optional Relations

```typescript
// ✅ Make relations optional
export interface Video extends VideoSchema {
  category?: Category;  // May not be loaded
  clubs?: Club;         // May not be loaded
}
```

### Pattern: Required Relations

```typescript
// ✅ Require specific relations
export interface VideoWithCategory extends VideoSchema {
  category: Category;  // Always loaded
}
```

### Pattern: Partial Relations

```typescript
// ✅ Partial relation data
export interface Video extends VideoSchema {
  category?: Pick<Category, 'id' | 'name' | 'code'>;
}
```

### Pattern: Array Relations

```typescript
// ✅ One-to-many relations
export interface Video extends VideoSchema {
  match_ids?: string[];
  matches?: Match[];
}
```

## Type Safety Best Practices

### 1. Use Specific Types

```typescript
// ✅ Good - specific type
function displayVideo(video: VideoWithMatch) {
  if (video.match) {
    console.log(video.match.home_team.name);
  }
}

// ❌ Bad - too generic
function displayVideo(video: any) {
  console.log(video.match?.home_team?.name);
}
```

### 2. Type Guards

```typescript
// ✅ Use type guards for runtime checks
function hasMatch(video: Video | VideoWithMatch): video is VideoWithMatch {
  return 'match' in video && video.match !== undefined;
}

if (hasMatch(video)) {
  // TypeScript knows video.match exists
  console.log(video.match.home_team.name);
}
```

### 3. Avoid Type Assertions

```typescript
// ❌ Bad - loses type safety
const video = data as any;

// ✅ Good - use proper types
const video: VideoSchema = data;
```

## Troubleshooting

### Issue: Type not found after generation

**Solution**: Check exports in index files

```typescript
// src/types/entities/video/index.ts
export * from './schema/videosSchema';
export * from './data/video';

// src/types/index.ts
export * from './entities/video';
```

### Issue: Type mismatch between schema and data

**Solution**: Regenerate types

```bash
npm run generate:types
npx tsc --noEmit
```

### Issue: Optional field becomes required

**Solution**: Check if using Insert type vs Schema type

```typescript
// Schema has optional fields
VideoSchema.description  // string | null

// Insert requires explicit null
VideoInsert.description  // string | null (must provide)
```

## AI Guidelines

When working with types:

1. **Check if type exists** before creating new ones
2. **Use schema types** for database operations
3. **Extend schema types** for application needs
4. **Create context-specific types** for clarity
5. **Never edit auto-generated files**
6. **Follow naming conventions**
7. **Export from index files**

## Related Documentation

- [Layered Architecture](./LAYERED_ARCHITECTURE.md) - How types fit in the architecture
- [Development Guidelines](../DEVELOPMENT_GUIDELINES.md) - Using types in development
- [Factory Patterns](./FACTORY_PATTERNS.md) - Type parameters for factories

## Questions?

- **"Schema vs Data type?"** → Schema for DB, Data for app
- **"When to create new type?"** → When you need specific context or relations
- **"Can I edit schema files?"** → No, they're auto-generated
- **"How to add relations?"** → Create data type extending schema
- **"Type not exported?"** → Check index.ts files
